# 按摩师
---
## 题目描述
&nbsp;&nbsp;一个有名的按摩师会源源不断的预约请求，每个预约都可以选择接或者不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合(总预约时间最长)，返回总的分钟数。

## 解题思路
### 个人思路
&nbsp;&nbsp;这道题目比较容易看出来是一道动态规划题目。主要的条件制约就是不能选择相邻的预约。要求是找到最优的预约集合，一般遇到最优那么最容易想到的就是贪心算法和动态规划算法。这道题目能够很好的找到动态规划的动态转移方程式。如我们假设dp[i][0]表示第i个人没有被预约的最优预约时长。那么第i个人前面的前两个人中一定是有一个是被预约的(这个可以使用反证法证明，假如前两个人没有被预约，那么明显会浪费一个名额，因为前面第3个人不管有没有被预约，前3个人中和第i个人之间一定能够被预约，这样不是最优解)。dp[i][1]表示第i个人被预约，那么其前面一位一定是不会被预约的。所以方程式是:
dp[i][0] = max(dp[i-1][0], dp[i-1][1])
dp[i][1] = dp[i-1][0] + nums[i-1]

### 借鉴思路
&nbsp;&nbsp;以上逻辑还可以简化，由于第i个人的最优解只和i-1有关，所以不需要创建dp数组来保存对应的数据，只要有两个变量,dp0和dp1来表示dp[i-1][0]和dp[i-1][1]即可。

##代码
### 个人代码
```go
func massage(nums []int) int {
    ln := len(nums)
    dp := make([][]int, ln+2)
    for i := 0; i < ln+2; i++ {
        dp[i] = make([]int, 2)
    }
    dp[0][0] = 0
    dp[0][1] = 0

    for i := 1; i <= ln; i++ {
        dp[i][0] = max(dp[i-1][0], dp[i-1][1])
        dp[i][1] = dp[i-1][0] + nums[i-1]
    }
    return max(dp[ln][0], dp[ln][1])
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 借鉴思路相关代码
```go
massage(nums []int) int {
    ln := len(nums)
    if ln == 0 {
        return 0
    }
    dp0, dp1 := 0, 0
    var tmp int

    for i := 1; i <= ln; i++ {
        tmp = max(dp0, dp1)
        dp1 = dp0 + nums[i-1]
        dp0 = tmp
    }
    return max(dp0, dp1)
}
```
